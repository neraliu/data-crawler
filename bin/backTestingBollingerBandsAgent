#!/usr/bin/env node
/*
Copyright (c) 2015, All rights reserved.
Copyrights licensed under the New BSD License.
See the accompanying LICENSE file for terms.

Authors: Nera Liu <neraliu@gmail.com>
*/
/*jshint -W083 */
/* promise */
var Promise = require('promise'),
    utils = require('../src/utils'),
    fs = require('fs');

(function() {

    // redis
    var redis = require("redis"),
        conf = utils.readConf("./conf/technical-analysis.conf");
        client = redis.createClient(conf.redisPort, conf.redisHost, {auth_pass: conf.redisPassword});

    var targets = conf.stocks,
        tests = conf.bollingerBands.tests,
        d = new Date(),
        ts = d.getTime();

    // technical analysis
    var TechnicalAnalysis = require("../src/technical-analysis.js").TechnicalAnalysis,
        ta = new TechnicalAnalysis();

    // main
    client.on("error", function (err) {
        console.log("[ERROR] " + err);
    });
    client.on("connect", function () {
        console.log("[AGENT] Redis connected!");
        targets.forEach(function(target, index) {

            (function() {

            // data 
            var dataSample = [],
                dataDate = [];

            // read data
            var readDataPromise = function(key) {
                return new Promise(function(resolve, reject) {
                    client.get(key, function(err, reply) {
                        if (reply !== null) {
                            console.log("[AGENT] Reading key: "+key+",value:"+reply);
                            dataSample.push(parseFloat(reply));
                            dataDate.push(key.substring(0, 6));
                        }
                        resolve(reply);
                    });
                });
            };
            var readData = function(key, seq) {
                return seq.then(function() { 
                    return readDataPromise(key); 
                });
            };

            var seq = new Promise(function(resolve, reject) {
                dataSample = [];
                dataDate = [];
                resolve(1);
            });

            // reading data
            var filePrefix = "./app/public/data/"+target.symbol+"/";
            for(var i=0;i<target.size;++i) {
                var d = new Date(ts-conf.ONE_DAY_MILLISECOND*i),
                y = d.getFullYear().toString().replace(/^20/, ""),
                m = d.getMonth()+1 < 10? "0"+(d.getMonth()+1) : d.getMonth()+1,
                da = d.getDate() < 10? "0"+d.getDate() : d.getDate(),
                dString = y+m+da;
                var key = dString+":"+target.symbol+":"+target.type;
                seq = readData(key, seq);
            }

            // reading data completed
            seq.then(function() {
                console.log("[AGENT] DataSample size: "+dataSample.length);
                dataSample = dataSample.reverse();
                dataDate = dataDate.reverse();
                return Promise.resolve();

            // bollinger bands trading algo
            }).then(function() {
                var results = [];

                // TODO: split it into different node to calculate
                for(var ma=tests.sMA;ma<=tests.eMA;ma+=tests.deltaMA) {
                for(var std=tests.sStd;std<=tests.eStd;std+=tests.deltaStd) {
                    std = Math.round(std*100)/100;

                    console.log("====================================================");
                    console.log("[AGENT] BollingerBands std:"+std);
                    console.log("[AGENT] BollingerBands ma:"+ma);

                    var bollingerBands = ta.bollingerBands(dataSample, ma, std, std);
                    bollingerBands.date = dataDate;

                    var trans = [],
                        size = 100,
                        amount = 0;

                    // back testing bollingBands trading algo 1
                    /* buy it when it is below the bollingerBands and sell it when it is above the bollingerBands with one transaction only */
                    dataSample.forEach(function(d, i) {
                        if (trans.length === 0 && 
                            !isNaN(bollingerBands.lower[i]) && bollingerBands.lower[i] >= d) {

                            console.log("[AGENT] Buy Signal @ "+d+"/"+bollingerBands.lower[i]+", date:"+bollingerBands.date[i]);
                            var tran = utils.saveBuyTransaction(target.symbol, d, tests.size, 
                                {"bollingerBandsLower":bollingerBands.lower[i], "ma":ma, "std":std});
                            trans.push(tran);

                        } else if (!isNaN(bollingerBands.upper[i]) && bollingerBands.upper[i] <= d) {
                            trans.forEach(function(t) {
                                if (t.status === 'open') {
                                    console.log("[AGENT] Sell Signal @ "+d+"/"+bollingerBands.upper[i]+", date:"+bollingerBands.date[i]);
                                    console.log("[AGENT] Executing Sell Signal @ "+d+"/"+bollingerBands.upper[i]+", date:"+bollingerBands.date[i]);
                                    utils.saveSellTransaction(t, d, tests.size, {"bollingerBandsUpper":bollingerBands.upper[i]});
                                }
                            });
                        }
                    });
                    results.push(trans);
                }
                }
                return Promise.resolve(results);
            // bollinger bands trading results
            }).then(function(results) {
                console.log("[AGENT] Completed!");

                var maxReturnTransaction;

                var o = '<h1>Transaction</h1>';
                o += '<table border="1">';
                o += '<tr><td>ma</td><td>std</td><td>profit</td><td>return</td></tr>';
                results.forEach(function(trans, i) {
                    trans.forEach(function(t, i) {
                        o += "<tr><td>"+t.extra.ma+"</td><td>"+t.extra.std+"</td><td>"+t.profitOrLoss+"</td><td>"+t.return+"</td>";
                        o += "</tr>";
                        maxReturnTransaction === undefined? maxReturnTransaction = t : '';
                        t.return > maxReturnTransaction.return ? maxReturnTransaction = t : '';
                    });
                });
                o += '</table>';

                o += '<h1>Max Return Transaction</h1>';
                o += '<table border="1">';
                o += "<tr><td>"+maxReturnTransaction.extra.ma+"</td><td>"+maxReturnTransaction.extra.std+"</td>";
                o += "<td>"+maxReturnTransaction.profitOrLoss+"</td><td>"+maxReturnTransaction.return+"</td></tr>";
                o += '</table>';

                o += "<br/><a href='index.html'>back</a>";
                utils.writeFile(filePrefix+"backTestingBollingerBandsAgent.html", o);

                o = "";
                results.forEach(function(trans, i) {
                    trans.forEach(function(t, i) {
                        o += t.extra.ma+","+t.extra.std+","+t.profitOrLoss+","+t.return+",";
                        o += "\n";
                    });
                });
                utils.writeFile(filePrefix+"backTestingBollingerBandsAgent.tsv", o);

                if (index+1 === targets.length) {
                    process.exit(0);
                }
                return Promise.resolve(0);
            });

            })();

        }); // targets.forEach
    });

}).call(this);
// http://www.html5rocks.com/en/tutorials/es6/promises/
